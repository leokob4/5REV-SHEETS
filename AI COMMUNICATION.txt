

refazer e reconectar com gui.py todos os ui/tools *.py para n√£o ligar para valores default, somente carregar as planilhas todas na ordem que est√£o.
verificar se n√£o √© obsoleto termos em db.xlsx a planilha tool_schemas

vamos garantir que n√£o sobrou no nosso c√≥digo py algum valor como:
"obs IA olhar em runtime e salvar"
que j√° alterei ou vou alterar todos na planilha e p√°gina e c√©lula necess√°ria manualmente e deixar o valor correto no db.
me ajude a explicar melhor na descri√ß√£o da ferramenta vista pelo usu√°rio o que a parte "atualizar schema db_db" e a parte "validar consist√™ncia do db" fazem

sumiu a funcao de gerar engenharia.xlsx de antes, est√° para ser gerado pela tool de admin no arquivo: create_engenharia_xlsx.py:
import os
import openpyxl

# Define o caminho do diret√≥rio user_sheets
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
user_sheets_dir = os.path.join(project_root, 'user_sheets')
os.makedirs(user_sheets_dir, exist_ok=True) # Garante que o diret√≥rio exista

file_path = os.path.join(user_sheets_dir, "engenharia.xlsx")
sheet_name = "Estrutura"

# Define os cabe√ßalhos para o arquivo engenharia.xlsx
ENGENHARIA_HEADERS = [
    "part_number", "parent_part_number", "quantidade", "materia_prima"
]

# Dados de exemplo para a estrutura de engenharia
# Representa uma √°rvore de componentes e mat√©rias-primas
sample_data = [
    # Produto Final (parent_part_number vazio ou N/A)
    ["PROD-001", "", 1, "N√£o"], # Produto Principal
    
    # Submontagens de PROD-001
    ["ASSY-A", "PROD-001", 1, "N√£o"], # Submontagem A
    ["ASSY-B", "PROD-001", 2, "N√£o"], # Submontagem B
    
    # Componentes de ASSY-A
    ["COMP-001", "ASSY-A", 5, "N√£o"], # Componente pr√©-fabricado
    ["RAW-MAT-001", "ASSY-A", 10, "Sim"], # Mat√©ria-prima 1
    
    # Componentes de ASSY-B
    ["COMP-002", "ASSY-B", 3, "N√£o"], # Componente 2
    ["RAW-MAT-002", "ASSY-B", 1, "Sim"], # Mat√©ria-prima 2
    ["RAW-MAT-003", "ASSY-B", 0.5, "Sim"], # Mat√©ria-prima 3 (por kg/metro)
    
    # Componentes de COMP-001 (se for uma sub-estrutura interna, por exemplo)
    ["SUB-COMP-01", "COMP-001", 1, "N√£o"],
    ["RAW-MAT-004", "COMP-001", 20, "Sim"]
]

def create_engenharia_xlsx():
    """Cria ou atualiza o arquivo engenharia.xlsx com os cabe√ßalhos e dados de exemplo."""
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = sheet_name

    # Adiciona os cabe√ßalhos
    ws.append(ENGENHARIA_HEADERS)

    # Adiciona os dados de exemplo
    for row_data in sample_data:
        ws.append(row_data)

    wb.save(file_path)
    print(f"Arquivo '{os.path.basename(file_path)}' criado/atualizado com a planilha '{sheet_name}'.")

if __name__ == "__main__":
    create_engenharia_xlsx()


e √© usado no ui/tools/engenharia_data.py

import sys
import os
import bcrypt
import openpyxl
import json # Necess√°rio para EngenhariaWorkflowTool (salvar/carregar JSON)
import subprocess # Necess√°rio para _run_create_engenharia_script, e agora para o atualizador de metadados

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QToolBar, QAction, QTabWidget, QMenu, QToolButton,
    QWidget, QVBoxLayout, QSplitter, QTreeWidget, QTreeWidgetItem,
    QLabel, QLineEdit, QPushButton, QHBoxLayout, QMessageBox, QGraphicsView,
    QGraphicsScene, QGraphicsRectItem, QGraphicsLineItem, QDialog, QListWidget, QListWidgetItem, QTableWidget, QTableWidgetItem, QHeaderView, QInputDialog, QComboBox, QGraphicsTextItem 
)
from PyQt5.QtCore import Qt, QPointF, QFileInfo
from PyQt5.QtGui import QBrush, QPen, QColor, QFont 

# --- Corre√ß√£o para ModuleNotFoundError: No module named 'ui' ---
# Obt√©m o caminho absoluto do diret√≥rio contendo gui.py
current_dir = os.path.dirname(os.path.abspath(__file__))
# Navega at√© a raiz do projeto (assumindo gui.py est√° em client/, e client/ est√° na raiz do projeto/)
project_root = os.path.dirname(current_dir) # Vari√°vel 'project_root' definida aqui (com 'p' min√∫sculo)
# Adiciona a raiz do projeto ao sys.path para que Python possa encontrar 'ui' e 'user_sheets' etc.
if project_root not in sys.path:
    sys.path.insert(0, project_root)

# --- Importar M√≥dulos das Ferramentas ---
# Garanta que esses arquivos existam em ui/tools/
from ui.tools.product_data import ProductDataTool
from ui.tools.bom_manager import BomManagerTool
from ui.tools.configurador import ConfiguradorTool
from ui.tools.colaboradores import ColaboradoresTool
from ui.tools.items import ItemsTool
from ui.tools.manufacturing import ManufacturingTool
from ui.tools.pcp import PcpTool
from ui.tools.estoque import EstoqueTool
from ui.tools.financeiro import FinanceiroTool 
from ui.tools.pedidos import PedidosTool
from ui.tools.manutencao import ManutencaoTool
from ui.tools.engenharia_data import EngenhariaDataTool 
from ui.tools.excel_viewer_tool import ExcelViewerTool 
from ui.tools.structure_view_tool import StructureViewTool
from ui.tools.rpi_tool import RpiTool 

# --- Configura√ß√£o dos Caminhos dos Arquivos ---
USER_SHEETS_DIR = os.path.join(project_root, "user_sheets")
APP_SHEETS_DIR = os.path.join(project_root, "app_sheets")

# Caminhos para arquivos Excel gerenciados pelo usu√°rio (na pasta user_sheets)
COLABORADORES_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "colaboradores.xlsx")
CONFIGURADOR_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "configurador.xlsx")
FINANCEIRO_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "financeiro.xlsx")
MANUTENCAO_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "manutencao.xlsx")
OUTPUT_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "output.xlsx") # Usado pela ProductDataTool
PEDIDOS_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "pedidos.xlsx")
PROGRAMACAO_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "programacao.xlsx") # Usado pela PcpTool
RPI_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "RPI.xlsx")
ESTOQUE_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "estoque.xlsx") # Usado pela ItemsTool
DB_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "db.xlsx")
ENGENHARIA_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "engenharia.xlsx")
BOM_DATA_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "bom_data.xlsx") # Padr√£o para BomManagerTool (se n√£o for engenharia.xlsx)
ITEMS_DATA_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "items_data.xlsx") # Arquivo items_data.xlsx original, se ainda for usado por outra ferramenta
MANUFACTURING_DATA_EXCEL_PATH = os.path.join(USER_SHEETS_DIR, "manufacturing_data.xlsx")

# Caminhos para arquivos Excel gerenciados pelo aplicativo (na pasta app_sheets)
TOOLS_EXCEL_PATH = os.path.join(APP_SHEETS_DIR, "tools.xlsx")
MODULES_EXCEL_PATH = os.path.join(APP_SHEETS_DIR, "modules.xlsx")
PERMISSIONS_EXCEL_PATH = os.path.join(APP_SHEETS_DIR, "permissions.xlsx")
ROLES_TOOLS_EXCEL_PATH = os.path.join(APP_SHEETS_DIR, "roles_tools.xlsx")
USERS_EXCEL_PATH = os.path.join(APP_SHEETS_DIR, "users.xlsx") # Conte√∫do da planilha 'users' no db.xlsx
MAIN_EXCEL_PATH = os.path.join(APP_SHEETS_DIR, "main.xlsx") # Assumindo que este arquivo existe ou ser√° criado

# --- NOVO: Caminho para o script de atualiza√ß√£o de metadados ---
# CORRE√á√ÉO: Usando 'project_root' (min√∫sculas)
UPDATE_METADATA_SCRIPT_PATH = os.path.join(APP_SHEETS_DIR, "tools", "update_user_sheets_metadata.py")
# --- NOVO: Caminho para o script de valida√ß√£o de sheets ---
# CORRE√á√ÉO: Usando 'project_root' (min√∫sculas)
SHEET_VALIDATOR_SCRIPT_PATH = os.path.join(project_root, "sheet validator", "sheet_validator.py")


# Lista de arquivos protegidos (n√£o podem ser exclu√≠dos ou renomeados via GUI)
PROTECTED_FILES = [
    os.path.basename(COLABORADORES_EXCEL_PATH),
    os.path.basename(CONFIGURADOR_EXCEL_PATH),
    os.path.basename(FINANCEIRO_EXCEL_PATH),
    os.path.basename(MANUTENCAO_EXCEL_PATH),
    os.path.basename(OUTPUT_EXCEL_PATH),
    os.path.basename(PEDIDOS_EXCEL_PATH),
    os.path.basename(PROGRAMACAO_EXCEL_PATH),
    os.path.basename(RPI_EXCEL_PATH),
    os.path.basename(ESTOQUE_EXCEL_PATH),
    os.path.basename(DB_EXCEL_PATH), # db.xlsx √© protegido
    os.path.basename(ENGENHARIA_EXCEL_PATH),
    os.path.basename(TOOLS_EXCEL_PATH),
    os.path.basename(MODULES_EXCEL_PATH),
    os.path.basename(PERMISSIONS_EXCEL_PATH),
    os.path.basename(ROLES_TOOLS_EXCEL_PATH),
    os.path.basename(USERS_EXCEL_PATH), # Redundante se db.xlsx for protegido, mas mantido para clareza
    os.path.basename(MAIN_EXCEL_PATH),
    # Adicione aqui o nome do arquivo do script de metadados se ele deve ser protegido
    os.path.basename(UPDATE_METADATA_SCRIPT_PATH),
    # CORRE√á√ÉO: Adicionado o validador √† lista de arquivos protegidos
    os.path.basename(SHEET_VALIDATOR_SCRIPT_PATH) 
]

# Garante que os diret√≥rios existam
os.makedirs(USER_SHEETS_DIR, exist_ok=True)
os.makedirs(APP_SHEETS_DIR, exist_ok=True)
# Garante que a pasta 'tools' dentro de 'app_sheets' exista
os.makedirs(os.path.dirname(UPDATE_METADATA_SCRIPT_PATH), exist_ok=True)
# Garante que a pasta 'sheet validator' exista
os.makedirs(os.path.dirname(SHEET_VALIDATOR_SCRIPT_PATH), exist_ok=True)


# Itens de espa√ßo de trabalho codificados (para a √°rvore de exemplo, antes da carga din√¢mica)
WORKSPACE_ITEMS = [
    "Demo Project - Rev A",
    "Part-001",
    "Assembly-001",
    "Sample Variant - V1.0",
    "Component-XYZ",
    "Specification-005",
    "Drawing-CAD-001",
    "PROD-001", 
    "ASSY-A", 
    "RAW-MAT-001", 
    "100001" 
]

# === FUN√á√ïES AUXILIARES DE PLANILHA ===
def load_users_from_excel():
    """Carrega dados de usu√°rio do arquivo Excel do banco de dados."""
    try:
        wb = openpyxl.load_workbook(DB_EXCEL_PATH)
        users_sheet = wb["users"]
        users = {}
        # Iterar a partir da segunda linha para pular os cabe√ßalhos
        for row in users_sheet.iter_rows(min_row=2):
            # Verifica se a linha tem c√©lulas suficientes antes de acessar
            if len(row) >= 4:
                users[row[1].value] = {
                    "id": row[0].value,
                    "username": row[1].value,
                    "password_hash": row[2].value,
                    "role": row[3].value
                }
        return users
    except FileNotFoundError:
        QMessageBox.critical(None, "Arquivo N√£o Encontrado", f"O arquivo do banco de dados n√£o foi encontrado: {DB_EXCEL_PATH}")
        return {}
    except KeyError:
        QMessageBox.critical(None, "Erro de Planilha", f"A planilha 'users' n√£o foi encontrada em {DB_EXCEL_PATH}")
        return {}
    except Exception as e:
        QMessageBox.critical(None, "Erro de Carregamento", f"Erro ao carregar usu√°rios: {e}")
        return {}

def register_user(username, password, role="user"):
    """Registra um novo usu√°rio no arquivo Excel do banco de dados."""
    try:
        wb = openpyxl.load_workbook(DB_EXCEL_PATH)
        sheet = wb["users"]
        next_id = sheet.max_row # Obt√©m o pr√≥ximo n√∫mero de linha dispon√≠vel para o ID
        # Garante nome de usu√°rio √∫nico
        for row in sheet.iter_rows(min_row=2):
            if row[1].value == username:
                raise ValueError("Nome de usu√°rio j√° existe.")

        password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()
        # Adiciona novos dados de usu√°rio √† planilha
        sheet.append([next_id, username, password_hash, role])
        wb.save(DB_EXCEL_PATH)
    except FileNotFoundError:
        QMessageBox.critical(None, "Arquivo N√£o Encontrado", f"O arquivo do banco de dados n√£o foi encontrado em: {DB_EXCEL_PATH}. N√£o √© poss√≠vel registrar o usu√°rio.")
    except KeyError:
        QMessageBox.critical(None, "Erro de Planilha", f"A planilha 'users' n√£o foi encontrada em {DB_EXCEL_PATH}. N√£o √© poss√≠vel registrar o usu√°rio.")
    except Exception as e:
        QMessageBox.critical(None, "Erro de Registro", f"Ocorreu um erro durante o registro do usu√°rio: {e}")

def load_tools_from_excel():
    """
    Carrega dados da ferramenta do arquivo Excel dedicado √†s ferramentas.
    """
    tools = {}
    try:
        if not os.path.exists(TOOLS_EXCEL_PATH):
            QMessageBox.critical(None, "Arquivo N√£o Encontrado", f"O arquivo de ferramentas n√£o foi encontrado em: {TOOLS_EXCEL_PATH}. Por favor, certifique-se de que ele exista.")
            return {}

        wb = openpyxl.load_workbook(TOOLS_EXCEL_PATH)
        sheet = wb["tools"] 
        
        if sheet.max_row < 2:
            QMessageBox.warning(None, "Planilha Vazia", f"A planilha 'tools' em {TOOLS_EXCEL_PATH} parece estar vazia ou conter apenas cabe√ßalhos.")
            return {}

        for row in sheet.iter_rows(min_row=2):
            if len(row) >= 4 and all(cell.value is not None for cell in row[:4]):
                tools[row[0].value] = {
                    "id": row[0].value,
                    "name": row[1].value,
                    "description": row[2].value,
                    "path": row[3].value
                }
    except KeyError:
        QMessageBox.critical(None, "Erro de Planilha", f"A planilha 'tools' n√£o foi encontrada em {TOOLS_EXCEL_PATH}. Por favor, certifique-se de que o nome da planilha seja 'tools'.")
        return {}
    except Exception as e:
        QMessageBox.critical(None, "Erro de Carregamento", f"Erro ao carregar ferramentas: {e}")
        return {}
    return tools


def load_role_permissions():
    """Carrega permiss√µes de papel do arquivo Excel do banco de dados."""
    perms = {}
    try:
        wb = openpyxl.load_workbook(DB_EXCEL_PATH)
        sheet = wb["access"] 
        perms = {}
        for row in sheet.iter_rows(min_row=2):
            if len(row) >= 2 and row[1].value is not None:
                perms[row[0].value] = row[1].value.split(",") if row[1].value.lower() != "all" else "all"
            else:
                print(f"Aviso: Ignorando linha malformada na planilha 'access': {', '.join(str(c.value) for c in row)}")
        return perms
    except FileNotFoundError:
        QMessageBox.critical(None, "Arquivo N√£o Encontrado", f"O arquivo do banco de dados n√£o foi encontrado em: {DB_EXCEL_PATH}")
        return {}
    except KeyError:
        QMessageBox.critical(None, "Erro de Planilha", f"A planilha 'access' n√£o foi encontrada em {DB_EXCEL_PATH}")
        return {}
    except Exception as e:
        QMessageBox.critical(None, "Erro de Carregamento", f"Erro ao carregar permiss√µes: {e}")
        return {}


# === JANELA DE LOGIN ===
class LoginWindow(QWidget):
    """
    A janela de login para o aplicativo.
    Lida com a autentica√ß√£o e registro de usu√°rios.
    """
    def __init__(self):
        super().__init__()
        self.setWindowTitle("5revolution Login")
        self.setGeometry(400, 200, 300, 180) 
        self.users = load_users_from_excel() 

        self._init_ui()

    def _init_ui(self):
        """Inicializa os elementos da interface do usu√°rio para a janela de login."""
        layout = QVBoxLayout()

        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("Nome de Usu√°rio")
        self.password_input = QLineEdit()
        self.password_input.setPlaceholderText("Senha")
        self.password_input.setEchoMode(QLineEdit.Password)
        self.password_input.returnPressed.connect(self.authenticate) 

        login_btn = QPushButton("Entrar")
        login_btn.clicked.connect(self.authenticate)

        register_btn = QPushButton("Registrar")
        register_btn.clicked.connect(self.handle_register)

        layout.addWidget(QLabel("Bem-vindo ao 5revolution"))
        layout.addWidget(self.username_input)
        layout.addWidget(self.password_input)

        btns_layout = QHBoxLayout()
        btns_layout.addWidget(login_btn)
        btns_layout.addWidget(register_btn)

        layout.addLayout(btns_layout)
        self.setLayout(layout)

    def authenticate(self):
        """Autentica o usu√°rio com base nas credenciais fornecidas."""
        uname = self.username_input.text().strip()
        pwd = self.password_input.text().strip()

        if not uname or not pwd:
            QMessageBox.warning(self, "Falha no Login", "Nome de usu√°rio e senha n√£o podem estar vazios.")
            return

        user = self.users.get(uname)

        if not user or not bcrypt.checkpw(pwd.encode(), user["password_hash"].encode()):
            QMessageBox.warning(self, "Falha no Login", "Nome de usu√°rio ou senha inv√°lidos.")
            return

        self.main = TeamcenterStyleGUI(user)
        self.main.showMaximized() 
        self.close() 

    def handle_register(self):
        """Lida com o registro de usu√°rio."""
        uname = self.username_input.text().strip()
        pwd = self.password_input.text().strip()

        if not uname or not pwd:
            QMessageBox.warning(self, "Erro de Valida√ß√£o", "Nome de usu√°rio e senha s√£o obrigat√≥rios para o registro.")
            return

        try:
            register_user(uname, pwd)
            QMessageBox.information(self, "Registrado", f"Usu√°rio '{uname}' registrado com sucesso com o papel 'user'.")
            self.users = load_users_from_excel() 
            self.username_input.clear()
            self.password_input.clear()
        except ValueError as ve:
            QMessageBox.warning(self, "Falha no Registro", str(ve))
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Ocorreu um erro durante o registro: {e}")

# === FERRAMENTA: ENGENHARIA WORKFLOW DIAGRAM ===
class EngenhariaWorkflowTool(QWidget):
    """
    Ferramenta para criar e visualizar diagramas de fluxo de trabalho.
    Pretende ser similar ao software "Dia" para diagramas b√°sicos.
    Permite salvar e carregar dados do diagrama para/de um arquivo Excel.
    """
    DEFAULT_DATA_EXCEL_FILENAME = "engenharia.xlsx"
    DEFAULT_SHEET_NAME = "Workflows" # Planilha padr√£o para salvar/carregar workflows

    def __init__(self, file_path=None):
        super().__init__()
        self.setWindowTitle("Engenharia (Workflow) Tool")
        
        self.file_path = file_path if file_path else os.path.join(
            os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 
            'user_sheets', self.DEFAULT_DATA_EXCEL_FILENAME
        )
        self.current_sheet_name = self.DEFAULT_SHEET_NAME

        self.layout = QVBoxLayout(self)

        # Controles de arquivo e planilha
        file_sheet_layout = QHBoxLayout()
        file_sheet_layout.addWidget(QLabel(f"<b>Arquivo:</b> {os.path.basename(self.file_path)}"))
        file_sheet_layout.addStretch()
        file_sheet_layout.addWidget(QLabel("Planilha:"))
        self.sheet_selector = QComboBox()
        self.sheet_selector.setMinimumWidth(150)
        self.sheet_selector.currentIndexChanged.connect(self._load_workflow_from_excel)
        file_sheet_layout.addWidget(self.sheet_selector)
        self.refresh_sheets_btn = QPushButton("Atualizar Abas")
        self.refresh_sheets_btn.clicked.connect(self._populate_sheet_selector)
        file_sheet_layout.addWidget(self.refresh_sheets_btn)
        self.layout.addLayout(file_sheet_layout)

        self.scene = QGraphicsScene()
        self.view = QGraphicsView(self.scene)
        self.layout.addWidget(self.view)

        # Bot√µes de controle de diagrama
        control_layout = QHBoxLayout()
        add_node_btn = QPushButton("Adicionar N√≥ de Tarefa")
        add_node_btn.clicked.connect(self._add_task_node)
        add_link_btn = QPushButton("Adicionar Liga√ß√£o de Depend√™ncia")
        add_link_btn.clicked.connect(self._add_dependency_link)
        clear_btn = QPushButton("Limpar Diagrama")
        clear_btn.clicked.connect(self._clear_diagram)
        save_btn = QPushButton("Salvar Workflow")
        save_btn.clicked.connect(self._save_workflow_to_excel)
        load_btn = QPushButton("Carregar Workflow")
        load_btn.clicked.connect(self._load_workflow_from_excel)

        control_layout.addWidget(add_node_btn)
        control_layout.addWidget(add_link_btn)
        control_layout.addWidget(clear_btn)
        control_layout.addWidget(save_btn)
        control_layout.addWidget(load_btn)
        self.layout.addLayout(control_layout)

        self.nodes = [] 
        self.node_properties = {} 
        self.links = [] 

        self._populate_sheet_selector() 

    def _populate_sheet_selector(self):
        """Popula o QComboBox com os nomes das planilhas do arquivo Excel."""
        self.sheet_selector.clear()
        os.makedirs(os.path.dirname(self.file_path), exist_ok=True)

        if not os.path.exists(self.file_path):
            QMessageBox.warning(self, "Arquivo N√£o Encontrado", f"O arquivo de dados n√£o foi encontrado: {os.path.basename(self.file_path)}. Ele ser√° criado com a aba padr√£o '{self.DEFAULT_SHEET_NAME}' ao salvar.")
            self.sheet_selector.addItem(self.DEFAULT_SHEET_NAME)
            self.current_sheet_name = self.DEFAULT_SHEET_NAME
            return

        try:
            wb = openpyxl.load_workbook(self.file_path, read_only=True)
            sheet_names = wb.sheetnames
            
            if not sheet_names:
                self.sheet_selector.addItem(self.DEFAULT_SHEET_NAME)
                QMessageBox.warning(self, "Nenhuma Planilha Encontrada", f"Nenhuma planilha encontrada em '{os.path.basename(self.file_path)}'. Adicionando a aba padr√£o '{self.DEFAULT_SHEET_NAME}'.")
            else:
                for sheet_name in sheet_names:
                    self.sheet_selector.addItem(sheet_name)
                
                default_index = self.sheet_selector.findText(self.DEFAULT_SHEET_NAME)
                if default_index != -1:
                    self.sheet_selector.setCurrentIndex(default_index)
                elif sheet_names:
                    self.sheet_selector.setCurrentIndex(0) 
                
                self.current_sheet_name = self.sheet_selector.currentText()
            
            self._load_workflow_from_excel() 

        except Exception as e:
            QMessageBox.critical(self, "Erro ao Listar Planilhas", f"Erro ao listar planilhas em '{os.path.basename(self.file_path)}': {e}")
            self.sheet_selector.addItem(self.DEFAULT_SHEET_NAME) 
            self.current_sheet_name = self.DEFAULT_SHEET_NAME

    def _save_workflow_to_excel(self):
        """
        Salva o estado atual do diagrama para a planilha Excel selecionada.
        Formato de exemplo no Excel:
        Sheet: "Workflows"
        Colunas: "Tipo", "ID", "X", "Y", "Largura", "Altura", "Texto", "Cor", "Conex√µes" (JSON de IDs conectados)
        Exemplo de Linha de N√≥: ["Node", "node1", 50, 50, 100, 50, "Fase de Design", "#ADD8E6", "[]"]
        Exemplo de Linha de Link: ["Link", "link1", start_node_id, end_node_id, 0, 0, "", "", "[]"]
        """
        current_sheet_name = self.sheet_selector.currentText()
        if not current_sheet_name:
            QMessageBox.warning(self, "Erro", "Selecione uma planilha para salvar.")
            return

        try:
            wb = None
            if not os.path.exists(self.file_path):
                wb = openpyxl.Workbook()
                ws = wb.active
                ws.title = current_sheet_name
            else:
                wb = openpyxl.load_workbook(self.file_path)
                if current_sheet_name not in wb.sheetnames:
                    ws = wb.create_sheet(current_sheet_name)
                else:
                    ws = wb[current_sheet_name]
            
            if ws.max_row > 1: 
                ws.delete_rows(2, ws.max_row) 

            workflow_headers = ["Tipo", "ID", "X", "Y", "Largura", "Altura", "Texto", "Cor", "Conex√µes"]
            current_excel_headers = [cell.value for cell in ws[1]] if ws.max_row > 0 else []

            if current_excel_headers != workflow_headers:
                if ws.max_row > 0: 
                    ws.delete_rows(1)
                ws.insert_rows(1) 
                ws.append(workflow_headers)
            elif not current_excel_headers: 
                ws.append(workflow_headers)

            for i, node_item in enumerate(self.nodes):
                node_id = f"node_{i}" 
                text_item = None
                for item in self.scene.items(node_item.boundingRect()): 
                    if isinstance(item, QGraphicsTextItem):
                        text_item = item
                        break
                
                node_text = text_item.toPlainText() if text_item else ""
                node_x = node_item.rect().x()
                node_y = node_item.rect().y()
                node_width = node_item.rect().width()
                node_height = node_item.rect().height()
                node_color = node_item.brush().color().name() 
                
                connections = [] 
                
                ws.append(["Node", node_id, node_x, node_y, node_width, node_height, node_text, node_color, json.dumps(connections)])

            for i, link_item in enumerate(self.links):
                link_id = f"link_{i}"
                ws.append(["Link", link_id, "", "", "", "", "", "", json.dumps({"source": "id_origem", "target": "id_destino"})])

            wb.save(self.file_path)
            QMessageBox.information(self, "Sucesso", f"Workflow salvo em '{current_sheet_name}' em '{os.path.basename(self.file_path)}'.")
        except Exception as e:
            QMessageBox.critical(self, "Erro ao Salvar", f"N√£o foi poss√≠vel salvar o workflow: {e}")

    def _load_workflow_from_excel(self):
        """
        Carrega um diagrama de fluxo de trabalho da planilha Excel selecionada.
        """
        self._clear_diagram() 
        current_sheet_name = self.sheet_selector.currentText()
        if not current_sheet_name or not os.path.exists(self.file_path):
            QMessageBox.warning(self, "Erro", "Arquivo ou planilha n√£o selecionados/encontrados para carregar.")
            return

        try:
            wb = openpyxl.load_workbook(self.file_path)
            if current_sheet_name not in wb.sheetnames:
                QMessageBox.warning(self, "Planilha N√£o Encontrada", f"A planilha '{current_sheet_name}' n√£o foi encontrada em '{os.path.basename(self.file_path)}'.")
                return

            sheet = wb[current_sheet_name]
            
            headers = [cell.value for cell in sheet[1]] if sheet.max_row > 0 else []
            header_map = {h: idx for idx, h in enumerate(headers)}

            loaded_nodes = {} 

            for row_idx in range(2, sheet.max_row + 1): 
                row_values = [cell.value for cell in sheet[row_idx]]
                row_type = row_values[header_map.get("Tipo")] if "Tipo" in header_map and header_map["Tipo"] < len(row_values) else None

                if row_type == "Node":
                    node_id = row_values[header_map.get("ID")] if "ID" in header_map and header_map["ID"] < len(row_values) else None
                    x = row_values[header_map.get("X")] if "X" in header_map and header_map["X"] < len(row_values) else 0
                    y = row_values[header_map.get("Y")] if "Y" in header_map and header_map["Y"] < len(row_values) else 0
                    width = row_values[header_map.get("Largura")] if "Largura" in header_map and header_map["Largura"] < len(row_values) else 100
                    height = row_values[header_map.get("Altura")] if "Altura" in header_map and header_map["Altura"] < len(row_values) else 50
                    text = row_values[header_map.get("Texto")] if "Texto" in header_map and header_map["Texto"] < len(row_values) else ""

                    text = str(text) if text is not None else "" 

                    color_name = row_values[header_map.get("Cor")] if "Cor" in header_map and header_map["Cor"] < len(row_values) else "lightblue"

                    if node_id:
                        node_rect = self.scene.addRect(x, y, width, height, QPen(Qt.black), QBrush(QColor(color_name)))
                        node_text_item = self.scene.addText(text) 
                        node_text_item.setPos(x + 5, y + 15) 
                        
                        self.nodes.append(node_rect)
                        loaded_nodes[node_id] = node_rect 

                elif row_type == "Link":
                    link_data_str = row_values[header_map.get("Conex√µes")] if "Conex√µes" in header_map and header_map["Conex√µes"] < len(row_values) else "{}"
                    try:
                        link_data = json.loads(link_data_str)
                        source_id = link_data.get("source")
                        target_id = link_data.get("target")

                        source_node = loaded_nodes.get(source_id)
                        target_node = loaded_nodes.get(target_id)

                        if source_node and target_node:
                            pen = QPen(Qt.darkGray, 2)
                            line = self.scene.addLine(
                                source_node.rect().x() + source_node.rect().width(), source_node.rect().y() + source_node.rect().height() / 2,
                                target_node.rect().x(), target_node.rect().y() + target_node.rect().height() / 2,
                                pen
                            )
                            self.links.append(line)
                    except json.JSONDecodeError:
                        print(f"Aviso: Dados de conex√£o inv√°lidos para link: {link_data_str}")

            QMessageBox.information(self, "Sucesso", f"Workflow carregado de '{current_sheet_name}' em '{os.path.basename(self.file_path)}'.")

        except Exception as e:
            QMessageBox.critical(self, "Erro ao Carregar", f"N√£o foi poss√≠vel carregar o workflow: {e}")

    def _add_sample_diagram_elements(self):
        """Adiciona alguns elementos de exemplo √† cena do diagrama ao iniciar."""
        node1 = self.scene.addRect(50, 50, 100, 50, QPen(Qt.black), QBrush(QColor("lightblue")))
        node2 = self.scene.addRect(200, 150, 100, 50, QPen(Qt.black), QBrush(QColor("lightgreen")))
        node3 = self.scene.addRect(350, 50, 100, 50, QPen(Qt.black), QBrush(QColor("lightcoral")))

        text_item1 = self.scene.addText("Fase de Design")
        text_item1.setPos(50 + 5, 50 + 15) 

        text_item2 = self.scene.addText("Revis√£o (Aprovado)")
        text_item2.setPos(200 + 5, 150 + 15)

        text_item3 = self.scene.addText("Prepara√ß√£o da Produ√ß√£o")
        text_item3.setPos(350 + 5, 50 + 15)

        self.nodes.extend([node1, node2, node3]) 

        pen = QPen(Qt.darkGray)
        pen.setWidth(2)
        link1 = self.scene.addLine(node1.x() + node1.rect().width(), node1.y() + node1.rect().height() / 2,
                                   node2.x(), node2.y() + node2.rect().height() / 2, pen)
        link2 = self.scene.addLine(node2.x() + node2.rect().width(), node2.y() + node2.rect().height() / 2,
                                   node3.x(), node3.y() + node3.rect().height() / 2, pen)
        self.links.extend([link1, link2])


    def _add_task_node(self):
        """Adiciona um novo n√≥ de tarefa gen√©rico ao diagrama."""
        x = 10 + len(self.nodes) * 120 
        y = 10 + (len(self.nodes) % 3) * 70
        
        node = self.scene.addRect(x, y, 100, 50, QPen(Qt.black), QBrush(QColor("#FFD700"))) 
        
        text_item = self.scene.addText(f"Nova Tarefa {len(self.nodes) + 1}")
        text_item.setPos(x + 5, y + 15) 
        
        self.nodes.append(node)
        self.view.centerOn(node)

    def _add_dependency_link(self):
        """
        Prompts user to select two nodes to link. (Conceptual, requires selection logic).
        """
        QMessageBox.information(self, "Adicionar Liga√ß√£o", "Clique em dois n√≥s de tarefa para criar uma liga√ß√£o. (L√≥gica de sele√ß√£o a ser implementada na pr√≥xima etapa)")

    def _clear_diagram(self):
        """Limpa todos os elementos do diagrama."""
        self.scene.clear()
        self.nodes = [] 
        self.links = []
        self.node_properties = {}
        QMessageBox.information(self, "Diagrama Limpo", "O diagrama foi limpo.")

# === NOVA FERRAMENTA: ATUALIZADOR DE CABE√áALHOS DO BD ===
class DbHeadersUpdaterTool(QWidget):
    """
    Ferramenta para atualizar a planilha 'db_db' em db.xlsx com cabe√ßalhos de todos
    os arquivos Excel nas pastas user_sheets e app_sheets, preservando descri√ß√µes existentes.
    """
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Atualizador de Cabe√ßalhos do Banco de Dados")
        self.layout = QVBoxLayout()
        self.setLayout(self.layout)

        self.status_label = QLabel("Clique em 'Atualizar' para coletar e salvar os cabe√ßalhos das planilhas.")
        self.layout.addWidget(self.status_label)

        self.update_button = QPushButton("Atualizar Cabe√ßalhos")
        self.update_button.clicked.connect(self._update_db_headers)
        self.layout.addWidget(self.update_button)

        self.table = QTableWidget()
        self.table.setEditTriggers(QTableWidget.NoEditTriggers) 
        self.table.setAlternatingRowColors(True)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.layout.addWidget(self.table)
        
        self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(["Arquivo (Caminho)", "Nome da Coluna (Cabe√ßalho)", "pagina_arquivo", "descr_variavel"])

    def _load_existing_db_db_data(self):
        """
        Carrega os dados existentes da planilha 'db_db' para um dicion√°rio de lookup.
        Retorna: um dicion√°rio onde a chave √© (caminho_relativo_arquivo, nome_coluna)
                 e o valor √© {'pagina_arquivo': ..., 'descr_variavel': ...}.
        """
        existing_data = {}
        try:
            if not os.path.exists(DB_EXCEL_PATH):
                return existing_data

            wb = openpyxl.load_workbook(DB_EXCEL_PATH)
            if "db_db" not in wb.sheetnames:
                return existing_data

            sheet = wb["db_db"]
            headers = [cell.value for cell in sheet[1]] if sheet.max_row > 0 else []
            header_map = {h: idx for idx, h in enumerate(headers)}

            # Garante que as colunas essenciais existem
            if not all(col in header_map for col in ["Arquivo (Caminho)", "Nome da Coluna (Cabe√ßalho)", "pagina_arquivo", "descr_variavel"]):
                print("Aviso: A planilha 'db_db' n√£o possui todos os cabe√ßalhos esperados.")
                return existing_data # N√£o podemos carregar corretamente sem os cabe√ßalhos

            for row_idx in range(2, sheet.max_row + 1):
                row_values = [cell.value for cell in sheet[row_idx]]
                
                file_path_raw = row_values[header_map["Arquivo (Caminho)"]]
                column_name = row_values[header_map["Nome da Coluna (Cabe√ßalho)"]]
                pagina_arquivo = row_values[header_map["pagina_arquivo"]]
                descr_variavel = row_values[header_map["descr_variavel"]]

                # Use o caminho relativo normalizado como chave
                normalized_path = file_path_raw.replace('\\', '/') # Normaliza para consist√™ncia
                
                if normalized_path and column_name:
                    existing_data[(normalized_path, str(column_name))] = {
                        'pagina_arquivo': pagina_arquivo if pagina_arquivo is not None else "",
                        'descr_variavel': descr_variavel if descr_variavel is not None else ""
                    }
        except Exception as e:
            QMessageBox.critical(self, "Erro de Carregamento", f"Erro ao carregar dados existentes de db_db: {e}")
        return existing_data

    def _update_db_headers(self):
        # Esta fun√ß√£o agora √© um placeholder ou pode ser removida/revisada
        # pois a l√≥gica principal ser√° movida para fun√ß√µes externas.
        QMessageBox.information(self, "A√ß√£o", "Esta fun√ß√£o ser√° executada via Ferramentas Admin no menu principal.")
        pass

# === CLASSE PRINCIPAL DA GUI ===
class TeamcenterStyleGUI(QMainWindow):
    def __init__(self, user_data):
        super().__init__()
        self.user_data = user_data
        self.current_user_role = user_data["role"]
        self.access_permissions = load_role_permissions()
        self.available_tools_metadata = load_tools_from_excel()
        self.setWindowTitle("5revolution ERP")
        self.setGeometry(100, 100, 1200, 800) # Tamanho padr√£o da janela
        self._init_ui()

    def _init_ui(self):
        """Inicializa os componentes principais da interface do usu√°rio."""
        self._create_toolbar_menu()
        self._create_main_layout()
        self._setup_initial_content()

    def _create_toolbar_menu(self):
        """Cria a barra de ferramentas superior e seus menus."""
        toolbar = self.addToolBar("Main Toolbar")
        toolbar.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)

        # Menu Arquivo
        file_menu_btn = QToolButton(self)
        file_menu_btn.setText("Arquivo")
        file_menu_btn.setPopupMode(QToolButton.InstantPopup)
        file_menu = QMenu(self)
        exit_action = QAction("Sair", self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        file_menu_btn.setMenu(file_menu)
        toolbar.addWidget(file_menu_btn)

        # Menu Ferramentas (din√¢mico com base nas permiss√µes)
        tools_menu_btn = QToolButton(self)
        tools_menu_btn.setText("Ferramentas")
        tools_menu_btn.setPopupMode(QToolButton.InstantPopup)
        tools_menu = QMenu(self)
        self._populate_tools_menu(tools_menu)
        tools_menu_btn.setMenu(tools_menu)
        toolbar.addWidget(tools_menu_btn)

        # Menu Ajuda
        help_menu_btn = QToolButton(self)
        help_menu_btn.setText("Ajuda")
        help_menu_btn.setPopupMode(QToolButton.InstantPopup)
        help_menu = QMenu(self)
        about_action = QAction("Sobre", self)
        about_action.triggered.connect(lambda: QMessageBox.information(self, "Sobre 5revolution", "Sistema ERP 5revolution v1.0"))
        help_menu.addAction(about_action)
        help_menu_btn.setMenu(help_menu)
        toolbar.addWidget(help_menu_btn)

        # Menu Admin (apenas para administradores)
        if self.current_user_role == "admin":
            admin_menu_btn = QToolButton(self)
            admin_menu_btn.setText("üëë Ferramentas Admin")
            admin_menu_btn.setPopupMode(QToolButton.InstantPopup)
            admin_menu = QMenu(self)
            
            # A√ß√£o para atualizar cabe√ßalhos das User Sheets
            update_user_sheets_action = QAction("Atualizar Cabe√ßalhos das User Sheets", self)
            update_user_sheets_action.triggered.connect(self._run_update_user_sheets_headers)
            admin_menu.addAction(update_user_sheets_action)

            # A√ß√£o para atualizar o schema db_db
            update_db_db_schema_action = QAction("Atualizar Schema db_db", self)
            update_db_db_schema_action.triggered.connect(self._run_update_db_db_schema)
            admin_menu.addAction(update_db_db_schema_action)

            # A√ß√£o para validar consist√™ncia do DB
            validate_db_consistency_action = QAction("Validar Consist√™ncia do DB", self)
            validate_db_consistency_action.triggered.connect(self._run_validate_db_consistency)
            admin_menu.addAction(validate_db_consistency_action)

            admin_menu_btn.setMenu(admin_menu)
            toolbar.addWidget(admin_menu_btn)


    def _populate_tools_menu(self, menu):
        """Popula o menu de ferramentas com base nas permiss√µes do usu√°rio."""
        user_allowed_modules = self.access_permissions.get(self.current_user_role, [])
        if user_allowed_modules == "all":
            # Se for "all", o usu√°rio tem acesso a todas as ferramentas
            allowed_tool_ids = self.available_tools_metadata.keys()
        else:
            # Caso contr√°rio, filtra pelas IDs dos m√≥dulos permitidos
            # Mapeia IDs de m√≥dulos para IDs de ferramentas se necess√°rio (supondo 1:1 por enquanto)
            allowed_tool_ids = user_allowed_modules 
        
        for tool_id, tool_info in self.available_tools_metadata.items():
            if tool_id in allowed_tool_ids:
                action = QAction(tool_info["name"], self)
                # Conecta a a√ß√£o para abrir a ferramenta correspondente
                action.triggered.connect(lambda checked, t_id=tool_id: self._open_tool(t_id))
                menu.addAction(action)

    def _open_tool(self, tool_id):
        """Abre a ferramenta selecionada em uma nova aba."""
        tool_info = self.available_tools_metadata.get(tool_id)
        if not tool_info:
            QMessageBox.warning(self, "Ferramenta N√£o Encontrada", f"A ferramenta com ID '{tool_id}' n√£o foi encontrada.")
            return

        tool_name = tool_info["name"]
        
        # Mapeamento de IDs de ferramentas para classes de ferramentas
        # Adicione aqui o mapeamento para suas novas ferramentas quando criadas
        tool_classes = {
            "mod1": BomManagerTool,
            "mod4": EngenhariaWorkflowTool, # Exemplo: Engenharia est√° mapeada para EngenhariaWorkflowTool
            # Adicione outros mapeamentos aqui conforme suas ferramentas em ui/tools/
            # Ex: "mod2": TwinSyncTool,
            # Ex: "mod3": ColaboradoresTool, (j√° tem importado, s√≥ mapear ID)
            # "mod5": ManufacturingTool,
            # "mod6": PcpTool,
            # "mod7": ItemsTool, # Ou EstoqueTool, depende de como mapeou
            # "mod8": FinanceiroTool,
            # "mod9": PedidosTool,
            # "mod10": ManutencaoTool,
        }

        # Dicion√°rio de caminhos para as classes de ferramentas que precisam de um caminho de arquivo
        tool_file_paths = {
            "mod4": ENGENHARIA_EXCEL_PATH, # EngenhariaWorkflowTool usa engenharia.xlsx
            # Adicione outros mapeamentos aqui se alguma ferramenta espec√≠fica precisar de um caminho de arquivo
            "mod3": COLABORADORES_EXCEL_PATH,
            "mod7": ESTOQUE_EXCEL_PATH,
            "mod8": FINANCEIRO_EXCEL_PATH,
            "mod10": MANUTENCAO_EXCEL_PATH,
            "mod9": PEDIDOS_EXCEL_PATH,
            "mod6": PROGRAMACAO_EXCEL_PATH, # Assumindo PCPTool usa programacao.xlsx
            "mod2": BOM_DATA_EXCEL_PATH, # Apenas um exemplo, ajuste conforme seu Twin Sync use
        }

        ToolClass = tool_classes.get(tool_id)
        if ToolClass:
            try:
                # Verifica se a ferramenta espera um 'file_path' no construtor
                if tool_id in tool_file_paths:
                    tool_instance = ToolClass(tool_file_paths[tool_id])
                else:
                    tool_instance = ToolClass()

                self.central_widget.addTab(tool_instance, tool_name)
                self.central_widget.setCurrentWidget(tool_instance)
            except Exception as e:
                QMessageBox.critical(self, "Erro ao Abrir Ferramenta", f"N√£o foi poss√≠vel abrir a ferramenta '{tool_name}': {e}")
        else:
            QMessageBox.warning(self, "Ferramenta N√£o Implementada", f"A ferramenta '{tool_name}' (ID: {tool_id}) ainda n√£o tem uma classe associada ou n√£o est√° implementada.")


    def _create_main_layout(self):
        """Cria o layout principal com a √°rvore de navega√ß√£o e as abas de trabalho."""
        main_splitter = QSplitter(Qt.Horizontal)
        self.setCentralWidget(main_splitter)

        # Painel Esquerdo (√Årvore de Navega√ß√£o)
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        self.tree_widget = QTreeWidget()
        self.tree_widget.setHeaderLabels(["Nome", "Tipo"]) # Define cabe√ßalhos
        self.tree_widget.itemDoubleClicked.connect(self._on_tree_item_double_clicked)
        left_layout.addWidget(QLabel("<h2>Espa√ßo de Trabalho</h2>"))
        left_layout.addWidget(self.tree_widget)
        main_splitter.addWidget(left_panel)

        # Painel Direito (Abas de Trabalho)
        self.central_widget = QTabWidget()
        self.central_widget.setTabsClosable(True)
        self.central_widget.tabCloseRequested.connect(self.central_widget.removeTab)
        main_splitter.addWidget(self.central_widget)

        # Define o tamanho inicial dos pain√©is
        main_splitter.setSizes([300, 900]) # 300px para a √°rvore, 900px para as abas

    def _setup_initial_content(self):
        """Popula a √°rvore de navega√ß√£o e pode abrir abas iniciais."""
        self._populate_workspace_tree()
        self._populate_file_system_tree()
        # N√£o abre nenhuma aba por padr√£o, o usu√°rio far√° isso.

    def _populate_workspace_tree(self):
        """Popula a se√ß√£o 'Espa√ßo de Trabalho' da √°rvore."""
        self.tree_widget.clear() # Limpa a √°rvore existente
        
        # Adiciona o item raiz "Projetos/Espa√ßo de Trabalho"
        workspace_root_item = QTreeWidgetItem(self.tree_widget, ["Projetos/Espa√ßo de Trabalho", "Pasta"])
        workspace_root_item.setExpanded(True) # Expande o item raiz
        
        # Adiciona itens de exemplo codificados
        for item_name in WORKSPACE_ITEMS:
            QTreeWidgetItem(workspace_root_item, [item_name, "Item"])

    def _populate_file_system_tree(self):
        """Popula as se√ß√µes 'Arquivos do Usu√°rio' e 'Arquivos do Sistema' da √°rvore."""
        # Se√ß√µes de arquivos
        user_files_root = QTreeWidgetItem(self.tree_widget, ["Arquivos do Usu√°rio (user_sheets)", "Pasta"])
        user_files_root.setExpanded(True)
        app_files_root = QTreeWidgetItem(self.tree_widget, ["Arquivos do Sistema (app_sheets)", "Pasta"])
        app_files_root.setExpanded(True)

        self._add_files_to_tree(USER_SHEETS_DIR, user_files_root)
        self._add_files_to_tree(APP_SHEETS_DIR, app_files_root)

    def _add_files_to_tree(self, directory, parent_item):
        """Adiciona arquivos .xlsx de um diret√≥rio √† √°rvore."""
        try:
            for filename in os.listdir(directory):
                if filename.endswith(".xlsx") and not filename.startswith('~$'): # Ignora arquivos tempor√°rios
                    file_path = os.path.join(directory, filename)
                    file_info = QFileInfo(file_path)
                    item = QTreeWidgetItem(parent_item, [file_info.fileName(), "Arquivo Excel"])
                    item.setData(0, Qt.UserRole, file_path) # Armazena o caminho completo
        except Exception as e:
            QMessageBox.warning(self, "Erro ao Listar Arquivos", f"N√£o foi poss√≠vel listar arquivos em {directory}: {e}")

    def _on_tree_item_double_clicked(self, item, column):
        """Lida com o clique duplo em um item da √°rvore."""
        file_path = item.data(0, Qt.UserRole) # Obt√©m o caminho do arquivo armazenado
        if file_path and os.path.exists(file_path):
            self._open_excel_file_in_viewer(file_path)
        elif not file_path:
            # Caso seja um n√≥ de pasta ou um item n√£o-arquivo
            pass
        else:
            QMessageBox.warning(self, "Arquivo N√£o Encontrado", f"O arquivo '{os.path.basename(file_path)}' n√£o existe ou o caminho est√° incorreto.")

    def _open_excel_file_in_viewer(self, file_path):
        """Abre um arquivo Excel usando o ExcelViewerTool."""
        tool_name = f"Viewer: {os.path.basename(file_path)}"
        
        # Verifica se a aba j√° est√° aberta para evitar duplicatas
        for i in range(self.central_widget.count()):
            if self.central_widget.tabText(i) == tool_name:
                self.central_widget.setCurrentIndex(i)
                return

        try:
            # Instancia e abre a ferramenta ExcelViewerTool
            excel_viewer_tool = ExcelViewerTool(file_path=file_path)
            self.central_widget.addTab(excel_viewer_tool, tool_name)
            self.central_widget.setCurrentWidget(excel_viewer_tool)
        except Exception as e:
            QMessageBox.critical(self, "Erro ao Abrir Arquivo", f"N√£o foi poss√≠vel abrir '{os.path.basename(file_path)}' no visualizador: {e}")
            
    # --- NOVAS FUN√á√ïES PARA EXECUTAR SCRIPTS EXTERNOS ---
    def _run_external_python_script(self, script_path, *args):
        """
        Executa um script Python externo em um processo separado.
        Exibe uma caixa de mensagem com o resultado.
        """
        # python_executable = sys.executable # Caminho para o execut√°vel Python atual
        # Em alguns ambientes, sys.executable pode n√£o ser 'python'.
        # Para scripts standalone, 'python' no PATH √© geralmente o que se quer.
        # No ambiente PyInstaller, sys.executable √© o execut√°vel do app.
        # Para compatibilidade, podemos tentar 'python' ou sys.executable.
        # Ou, para garantir que o ambiente virtual seja usado, chamar como m√≥dulo.

        # Chamada mais robusta para PyInstaller e ambientes virtuais
        cmd = [sys.executable, script_path] + list(args)
        
        try:
            # shell=False √© mais seguro e prefer√≠vel
            # text=True (ou universal_newlines=True para py < 3.7) para capturar stdout/stderr como texto
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            output = result.stdout.strip()
            error = result.stderr.strip()

            if result.returncode == 0:
                QMessageBox.information(self, "Sucesso na Execu√ß√£o do Script", f"Script executado com sucesso:\n\n{output}")
                print(f"Sucesso: {output}") # Imprime tamb√©m no console para depura√ß√£o
            else:
                QMessageBox.critical(self, "Erro na Execu√ß√£o do Script", f"O script retornou um erro (C√≥digo: {result.returncode}):\n\n{error}\n{output}")
                print(f"Erro: {error}\nOutput: {output}") # Imprime no console
        except FileNotFoundError:
            QMessageBox.critical(self, "Erro de Arquivo", f"O execut√°vel Python ou o script '{os.path.basename(script_path)}' n√£o foi encontrado. Verifique o PATH ou o caminho do script.")
            print(f"Erro: Python executable or script '{script_path}' not found.")
        except subprocess.CalledProcessError as e:
            QMessageBox.critical(self, "Erro no Processo", f"O script '{os.path.basename(script_path)}' falhou:\n\n{e.stdout}\n{e.stderr}")
            print(f"Erro no processo: {e.stdout}\n{e.stderr}")
        except Exception as e:
            QMessageBox.critical(self, "Erro Inesperado", f"Ocorreu um erro inesperado ao tentar executar o script '{os.path.basename(script_path)}': {e}")
            print(f"Erro inesperado ao executar script: {e}")

    def _run_update_user_sheets_headers(self):
        """Executa o script para atualizar os cabe√ßalhos das user_sheets."""
        self._run_external_python_script(UPDATE_METADATA_SCRIPT_PATH, "update_user_sheets")
        # Ap√≥s a atualiza√ß√£o, recarrega a √°rvore de arquivos para refletir poss√≠veis mudan√ßas
        self._populate_file_system_tree()

    def _run_update_db_db_schema(self):
        """Executa o script para atualizar o schema db_db com os cabe√ßalhos reais."""
        self._run_external_python_script(UPDATE_METADATA_SCRIPT_PATH, "update_db_schema")
        # A db_db √© um arquivo de sistema/metadados, n√£o um arquivo que aparece na √°rvore user_sheets/app_sheets
        # Recarregar o tree_widget pode n√£o ser necess√°rio, mas n√£o faz mal.
        self._populate_file_system_tree()


    def _run_validate_db_consistency(self):
        """Executa o script para validar a consist√™ncia do DB."""
        self._run_external_python_script(SHEET_VALIDATOR_SCRIPT_PATH, "validate")
        # A valida√ß√£o apenas gera um relat√≥rio, n√£o altera arquivos vis√≠veis diretamente,
        # ent√£o n√£o h√° necessidade de recarregar a √°rvore.

# === IN√çCIO DO APLICATIVO ===
if __name__ == "__main__":
    app = QApplication(sys.argv)
    
    # Cria a janela de login e a mostra
    login_window = LoginWindow()
    login_window.show()
    
    sys.exit(app.exec_())

;

Arrumar essa parte para puxar dados do engenharia.xlsx, criado pelo nosso scritp, que tamb√©m tem que ser arrumado, j√° que est√° executando com sucesso por√©m n√£o gera a planilha na pasta user_sheets como deveria.
Resolver problema da imagem ao tentar carregar Arquivos do Sistema (app_sheets)
Resolver esses scripts que n√£o est√£o fazendo o que deveria.

tratar avisosde Aviso: Ignorando linha malformada na planilha 'access': None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None

adapte o que voc√™ acabou de dizer para utilizar a pasta j√° existente "sheet validator" na raiz do projeto, tamb√©m precisamos adicionar que iremos criar o uptade_user_sheets_metadata.py na pasta tools, e ser√° uma ferramenta de admin como a outra que tamb√©m mexe com db.xlsx, execut√°vel atrav√©s da gui.

  File "C:\Users\leona\OneDrive\Documentos\GitHub\5REV-SHEETS\client\gui.py", line 36, in <module>
    from ui.tools.financeiro import FinanceolTool
ImportError: cannot import name 'FinanceolTool' from 'ui.tools.financeiro' (C:\Users\leona\OneDrive\Documentos\GitHub\5REV-SHEETS\ui\tools\financeiro.py)

fa√ßa um script r√°pido para atualizarmos nossas user_sheets para terem as informa√ß√µes de db.xlsx da p√°gina db_updated, sembrando, sem conjuntos de dados no meio do script.
fa√ßa nosso sheet_validator.py, da pasta raiz:5REV-SHEETS/sheet validator; ser capaz de verificar se os dados de db_db est√£o atualizados conforme os das demais planilhas das quais ele depende, ou retornar as diferen√ßas.

WORKSPACE_ITEMS tem que ser carregado da mem√≥ria sobre o usu√°rio otherwise √© in√∫til.
Implementar mini console com uma linha para digitar input e 3 para ler logs do app, da mesma largura que o espa√ßo de trabalho do lado esquerdo.

os arquivos da pasta app_sheets est√£o com erro ao tentar carregar.
o script create_engenharia_xlsx.py falhou em criar a planilha corretamente na pasta user_sheets.
  File "C:\Users\leona\OneDrive\Documentos\GitHub\5REV-SHEETS\client\gui.py", line 1319, in _run_create_engenharia_script
    result = subprocess.run([sys.executable, script_path], capture_output=True, text=True, check=True)
             ^^^^^^^^^^
NameError: name 'subprocess' is not defined. Did you forget to import 'subprocess'?

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\leona\OneDrive\Documentos\GitHub\5REV-SHEETS\client\gui.py", line 1325, in _run_create_engenharia_script
    except subprocess.CalledProcessError as e:
           ^^^^^^^^^^
NameError: name 'subprocess' is not defined. Did you forget to import 'subprocess'?

engenharia workflow bugou, com o erro:  File "C:\Users\leona\OneDrive\Documentos\GitHub\5REV-SHEETS\client\gui.py", line 507, in <lambda>
    action.triggered.connect(lambda chk=False, title=tool["name"]: self._open_tab(title, EngenhariaWorkflowTool()))
                                                                                         ~~~~~~~~~~~~~~~~~~~~~~^^
  File "C:\Users\leona\OneDrive\Documentos\GitHub\5REV-SHEETS\client\gui.py", line 315, in __init__
    self._add_sample_diagram_elements()
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^
  File "C:\Users\leona\OneDrive\Documentos\GitHub\5REV-SHEETS\client\gui.py", line 339, in _add_sample_diagram_elements
    self.scene.addText("Fase de Design", QPointF(55, 65))
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: addText(self, text: Optional[str], font: QFont = QFont()): argument 2 has unexpected type 'QPointF';
vamos aproveitar que j√° temos que alterar mesmo para deixar essa tool integrada com nossas planilhas existente e com a capacidade de fazer diagramas similar a do sofware "Dia" de diagrams.
ele precisa salvar os workflows em alguma planilha existente na user_sheets e app_sheets; antes de desenvolver vou te mostrar mais dados inclusos no app, ok?

voc√™ esqueceu de colocar nas √∫ltimas mensagens a parte da janela de configura√ß√µes do perfil logado, que tinha uma tela feita anteriormente para mostrar os campos do perfil.

criar tabela engenharia.xlsx com part_number parent_part_number que seria correspondente de cada part_number a uma estrutura de dados que cont√©m a √°rvore de componentes(part_number, acompanha mais uma coluna contendo sua quantidade no item pai) e a mat√©ria prima(s√£o part_number tamb√©m)
e utilizar√° a tool de visualisar estrutura(structure view tool) e gerenciador de bom e engenharia workflow tool e visto como somente leitura pelo items.py e pela rpi_tool;
fazer items.py utilizar estoque.xlsx linhas 1 e 2:


criar atalho no gui.py para executar a tool create_engenharia_xlsx.py (somente administrador, conforme no sistema j√° existente, se quiser posso compartilhar a estrutura do projeto)
Ajustar para sempre abrir o app em tela cheia ap√≥s login.
Ajustar caminhos do arquivo e nomes do arqui tools para usarem dados atualizados do usu√°rio na pasta user_sheets, por favor antes disso analisar minhas alteracoes na primeira linha e demais dados nas planilhas que vou enviar, s√£o agora as mesmas contidas em user_sheets
em cada tool que √© capaz de editar as c√©lulas das planilhas, precisamos garantir que o usu√°rio n√£o colocar√° inputs do formato incorreto, o correto deve ser o mesmo tipo que o input da c√©lula, e ser formatado corretamente quando for alterado.
Fazer tool para atualizar p√°gina db_db db.xlsx contentdo dados dos headers das planilhas do user_sheets e app_sheets;
tornar a√ß√£o simulada de deletar arquivo real, dando prote√ß√£o contra remocao e alteracao de nome para as planilhas:
user_sheets/
colaboradores.xlsx
configurador.xlsx
financeiro.xlsx
manutencao.xlsx
output.xlsx
pedidos.xlsx
programacao.xlsx
RPI.xlsx
estoque.xlsx
db.xlsx
engenharia.xlsx
app_sheets/
tools.xlsx
modules.xlsx
permissions.xlsx
roles_tools.xlsx
users.xlsx
main.xlsx
a p√°gina db_db, do arquivo db.xlsx deve ficar com a primeira coluna com os campos arquivo(correspondendo ao caminho do *xlsx) e nome_coluna(correspondendo a cada primeira linha de cada p√°gina de cada outra planilha mencionada) ,segunda coluna igual ao nome esrito na c√©lula(por exempo o part_number)

erros a corrigir:
nessa √∫ltima vers√£o enviada por voc√™ n√£o est√° fazendo login com a tecla enter.
o app tamb√©m est√° mostrando duplicatas das user sheets que realmente n√£o est√£o nas planilhas.
ao abrir as tools que mexem com as planilhas, tamb√©m deveria ser por padr√£o a primeira p√°gina da planilha, mas atualmente est√° definindo uma p√°gina com nome fixo.
  File "C:\Users\leona\OneDrive\Documentos\GitHub\5REV-SHEETS\client\gui.py", line 381, in <lambda>
    action.triggered.connect(lambda chk=False, title=tool["name"]: self._open_tab(title, EngenhariaWorkflowTool()))
                                                                                         ~~~~~~~~~~~~~~~~~~~~~~^^
  File "C:\Users\leona\OneDrive\Documentos\GitHub\5REV-SHEETS\client\gui.py", line 280, in __init__
    self._add_sample_diagram_elements()
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^
  File "C:\Users\leona\OneDrive\Documentos\GitHub\5REV-SHEETS\client\gui.py", line 301, in _add_sample_diagram_elements
    node1 = self.scene.addRect(50, 50, 100, 50, QPen(Qt.black), QBrush(Qt.lightblue))
                                                                       ^^^^^^^^^^^^
AttributeError: type object 'Qt' has no attribute 'lightblue'


